Compiled from "Collections.java"
public class java.util.Collections {
  public static final java.util.Set EMPTY_SET;
  public static final java.util.List EMPTY_LIST;
  public static final java.util.Map EMPTY_MAP;
  public static <T extends java.lang.Comparable<? super T>> void sort(java.util.List<T>);
  public static <T> void sort(java.util.List<T>, java.util.Comparator<? super T>);
  public static <T> int binarySearch(java.util.List<? extends java.lang.Comparable<? super T>>, T);
  public static <T> int binarySearch(java.util.List<? extends T>, T, java.util.Comparator<? super T>);
  public static void reverse(java.util.List<?>);
  public static void shuffle(java.util.List<?>);
  public static void shuffle(java.util.List<?>, java.util.Random);
  public static void swap(java.util.List<?>, int, int);
  public static <T> void fill(java.util.List<? super T>, T);
  public static <T> void copy(java.util.List<? super T>, java.util.List<? extends T>);
  public static <T extends java.lang.Comparable<? super T>> T min(java.util.Collection<? extends T>);
  public static <T> T min(java.util.Collection<? extends T>, java.util.Comparator<? super T>);
  public static <T extends java.lang.Comparable<? super T>> T max(java.util.Collection<? extends T>);
  public static <T> T max(java.util.Collection<? extends T>, java.util.Comparator<? super T>);
  public static void rotate(java.util.List<?>, int);
  public static <T> boolean replaceAll(java.util.List<T>, T, T);
  public static int indexOfSubList(java.util.List<?>, java.util.List<?>);
  public static int lastIndexOfSubList(java.util.List<?>, java.util.List<?>);
  public static <T> java.util.Collection<T> unmodifiableCollection(java.util.Collection<? extends T>);
  public static <T> java.util.Set<T> unmodifiableSet(java.util.Set<? extends T>);
  public static <T> java.util.SortedSet<T> unmodifiableSortedSet(java.util.SortedSet<T>);
  public static <T> java.util.NavigableSet<T> unmodifiableNavigableSet(java.util.NavigableSet<T>);
  public static <T> java.util.List<T> unmodifiableList(java.util.List<? extends T>);
  public static <K, V> java.util.Map<K, V> unmodifiableMap(java.util.Map<? extends K, ? extends V>);
  public static <K, V> java.util.SortedMap<K, V> unmodifiableSortedMap(java.util.SortedMap<K, ? extends V>);
  public static <K, V> java.util.NavigableMap<K, V> unmodifiableNavigableMap(java.util.NavigableMap<K, ? extends V>);
  public static <T> java.util.Collection<T> synchronizedCollection(java.util.Collection<T>);
  static <T> java.util.Collection<T> synchronizedCollection(java.util.Collection<T>, java.lang.Object);
  public static <T> java.util.Set<T> synchronizedSet(java.util.Set<T>);
  static <T> java.util.Set<T> synchronizedSet(java.util.Set<T>, java.lang.Object);
  public static <T> java.util.SortedSet<T> synchronizedSortedSet(java.util.SortedSet<T>);
  public static <T> java.util.NavigableSet<T> synchronizedNavigableSet(java.util.NavigableSet<T>);
  public static <T> java.util.List<T> synchronizedList(java.util.List<T>);
  static <T> java.util.List<T> synchronizedList(java.util.List<T>, java.lang.Object);
  public static <K, V> java.util.Map<K, V> synchronizedMap(java.util.Map<K, V>);
  public static <K, V> java.util.SortedMap<K, V> synchronizedSortedMap(java.util.SortedMap<K, V>);
  public static <K, V> java.util.NavigableMap<K, V> synchronizedNavigableMap(java.util.NavigableMap<K, V>);
  public static <E> java.util.Collection<E> checkedCollection(java.util.Collection<E>, java.lang.Class<E>);
  static <T> T[] zeroLengthArray(java.lang.Class<T>);
  public static <E> java.util.Queue<E> checkedQueue(java.util.Queue<E>, java.lang.Class<E>);
  public static <E> java.util.Set<E> checkedSet(java.util.Set<E>, java.lang.Class<E>);
  public static <E> java.util.SortedSet<E> checkedSortedSet(java.util.SortedSet<E>, java.lang.Class<E>);
  public static <E> java.util.NavigableSet<E> checkedNavigableSet(java.util.NavigableSet<E>, java.lang.Class<E>);
  public static <E> java.util.List<E> checkedList(java.util.List<E>, java.lang.Class<E>);
  public static <K, V> java.util.Map<K, V> checkedMap(java.util.Map<K, V>, java.lang.Class<K>, java.lang.Class<V>);
  public static <K, V> java.util.SortedMap<K, V> checkedSortedMap(java.util.SortedMap<K, V>, java.lang.Class<K>, java.lang.Class<V>);
  public static <K, V> java.util.NavigableMap<K, V> checkedNavigableMap(java.util.NavigableMap<K, V>, java.lang.Class<K>, java.lang.Class<V>);
  public static <T> java.util.Iterator<T> emptyIterator();
  public static <T> java.util.ListIterator<T> emptyListIterator();
  public static <T> java.util.Enumeration<T> emptyEnumeration();
  public static final <T> java.util.Set<T> emptySet();
  public static <E> java.util.SortedSet<E> emptySortedSet();
  public static <E> java.util.NavigableSet<E> emptyNavigableSet();
  public static final <T> java.util.List<T> emptyList();
  public static final <K, V> java.util.Map<K, V> emptyMap();
  public static final <K, V> java.util.SortedMap<K, V> emptySortedMap();
  public static final <K, V> java.util.NavigableMap<K, V> emptyNavigableMap();
  public static <T> java.util.Set<T> singleton(T);
  static <E> java.util.Iterator<E> singletonIterator(E);
  static <T> java.util.Spliterator<T> singletonSpliterator(T);
  public static <T> java.util.List<T> singletonList(T);
  public static <K, V> java.util.Map<K, V> singletonMap(K, V);
  public static <T> java.util.List<T> nCopies(int, T);
  public static <T> java.util.Comparator<T> reverseOrder();
  public static <T> java.util.Comparator<T> reverseOrder(java.util.Comparator<T>);
  public static <T> java.util.Enumeration<T> enumeration(java.util.Collection<T>);
  public static <T> java.util.ArrayList<T> list(java.util.Enumeration<T>);
  static boolean eq(java.lang.Object, java.lang.Object);
  public static int frequency(java.util.Collection<?>, java.lang.Object);
  public static boolean disjoint(java.util.Collection<?>, java.util.Collection<?>);
  public static <T> boolean addAll(java.util.Collection<? super T>, T...);
  public static <E> java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean>);
  public static <T> java.util.Queue<T> asLifoQueue(java.util.Deque<T>);
  static {};
}
